{"version":3,"file":"string-replace-middleware.cjs.production.min.js","sources":["../src/stringReplaceStream.ts","../src/index.ts"],"sourcesContent":["import { Transform, TransformCallback } from 'stream';\nimport escapeStringRegexp from 'escape-string-regexp';\n\ntype Options = {\n  encoding: BufferEncoding;\n  ignoreCase: boolean;\n};\ntype Replacer = {\n  matcher: RegExp;\n  replace: string;\n};\n\nconst defaultOptions: Options = {\n  encoding: 'utf8',\n  ignoreCase: true,\n};\n\nfunction buildReplacers(\n  replacements: Record<string, string>,\n  opts: Options\n): Replacer[] {\n  return Object.keys(replacements)\n    .sort((a, b) => b.length - a.length)\n    .map(search => ({\n      matcher: new RegExp(\n        escapeStringRegexp(search),\n        opts.ignoreCase ? 'gmi' : 'gm'\n      ),\n      replace: replacements[search],\n    }));\n}\n\nfunction getMaxSearchLength(replacements: Record<string, string>): number {\n  return Object.keys(replacements).reduce(\n    (acc, search) => Math.max(acc, search.length),\n    0\n  );\n}\n\nexport default function StringReplaceStream(\n  replacements: Record<string, string>,\n  options: Partial<Options> = {}\n) {\n  const opts: Options = { ...defaultOptions, ...options };\n  const replacers = buildReplacers(replacements, opts);\n  const maxSearchLength = getMaxSearchLength(replacements);\n  let tail = '';\n\n  const replaceSlidingWindow = (\n    haystack: string,\n    replacers: Replacer[],\n    replaceBefore: number\n  ) => {\n    /**\n     * foo => foo123\n     * foo ba | r ba\n     * foo123 ba | r baz\n     * foo123 | bar baz\n     *\n     * foo => f\n     * foo bar baz => f bar baz\n     */\n    let body = haystack;\n    replacers.forEach(replacer => {\n      body =\n        body\n          .slice(0, replaceBefore)\n          .replace(replacer.matcher, replacer.replace) +\n        body.slice(replaceBefore);\n    });\n\n    return [body.slice(0, replaceBefore), body.slice(replaceBefore)];\n  };\n\n  const transform = function(\n    buf: Buffer,\n    _enc: BufferEncoding,\n    cb: TransformCallback\n  ) {\n    const replaceBefore = maxSearchLength * 2;\n    const haystack = tail + buf.toString(opts.encoding);\n    let body = '';\n\n    if (haystack.length < maxSearchLength * 3 - 2) {\n      tail = haystack;\n      cb(null, '');\n      return;\n    }\n\n    [body, tail] = replaceSlidingWindow(haystack, replacers, replaceBefore);\n\n    cb(null, body);\n  };\n  const flush = function(cb: TransformCallback) {\n    if (!tail) {\n      cb();\n      return;\n    }\n\n    const body = replacers.reduce(\n      (acc, replacer) => acc.replace(replacer.matcher, replacer.replace),\n      tail\n    );\n    cb(null, body);\n  };\n\n  return new Transform({ transform, flush });\n}\n","import { NextFunction, Request, Response } from 'express';\nimport hijackResponse from 'hijackresponse';\nimport stringReplaceStream from './stringReplaceStream';\n\nexport type Options = Record<'contentTypeFilterRegexp', RegExp>;\n\nexport type ReplaceFunction = (req: Request, res: Response) => string;\n\nconst defaultOptions: Options = {\n  contentTypeFilterRegexp: /^text\\/|^application\\/json$|^application\\/xml$/,\n};\n\nexport const stringReplace = (\n  replacements: Record<string, string | ReplaceFunction>,\n  options: Partial<Options> = {}\n) => {\n  const opts = { ...defaultOptions, ...options };\n\n  // Split string and function replacements so we don't have to process them on every request\n  const stringReplacements: Record<string, string> = {};\n  const functionReplacements: Record<string, ReplaceFunction> = {};\n  Object.keys(replacements).forEach(function(key, _index) {\n    const replacement = replacements[key];\n    if (typeof replacement === 'function') {\n      functionReplacements[key] = replacement;\n    } else {\n      stringReplacements[key] = replacement;\n    }\n  });\n  const hasFunctionReplacements = Object.keys(functionReplacements).length > 0;\n\n  return (req: Request, originalResponse: Response, next: NextFunction) => {\n    hijackResponse(originalResponse, function(err, res) {\n      const contentType = res.get('content-type') || '';\n      if (opts.contentTypeFilterRegexp.test(contentType)) {\n        if (err) {\n          res.unhijack(); // Make the original res object work again\n          return next(err);\n        }\n        res.removeHeader('content-length');\n\n        let scopedReplacements: Record<string, string>;\n        if (hasFunctionReplacements) {\n          // If we have dynamic replacements, calculate for this request\n          scopedReplacements = { ...stringReplacements };\n          Object.keys(functionReplacements).forEach(function(key, _index) {\n            scopedReplacements[key] = functionReplacements[key](req, res);\n          });\n        } else {\n          // No dynamic replacements, safe to share the global\n          scopedReplacements = stringReplacements;\n        }\n\n        res.pipe(stringReplaceStream(scopedReplacements)).pipe(res);\n      } else {\n        return res.unhijack();\n      }\n    });\n    next();\n  };\n};\n\nmodule.exports = stringReplace;\nmodule.exports.stringReplace = stringReplace;\n"],"names":["defaultOptions","encoding","ignoreCase","contentTypeFilterRegexp","stringReplace","replacements","options","opts","_extends","stringReplacements","functionReplacements","Object","keys","forEach","key","_index","replacement","hasFunctionReplacements","length","req","originalResponse","next","hijackResponse","err","res","scopedReplacements","contentType","get","test","unhijack","removeHeader","pipe","replacers","sort","a","b","map","search","matcher","RegExp","escapeStringRegexp","replace","buildReplacers","maxSearchLength","reduce","acc","Math","max","getMaxSearchLength","tail","Transform","transform","buf","_enc","cb","replaceBefore","haystack","toString","_replaceSlidingWindow","body","replacer","slice","replaceSlidingWindow","flush","stringReplaceStream","module","exports"],"mappings":"ycAYA,IAAMA,EAA0B,CAC9BC,SAAU,OACVC,YAAY,GCNRF,EAA0B,CAC9BG,wBAAyB,kDAGdC,EAAgB,SAC3BC,EACAC,YAAAA,IAAAA,EAA4B,IAE5B,IAAMC,EAAIC,KAAQR,EAAmBM,GAG/BG,EAA6C,GAC7CC,EAAwD,GAC9DC,OAAOC,KAAKP,GAAcQ,SAAQ,SAASC,EAAKC,GAC9C,IAAMC,EAAcX,EAAaS,GACN,mBAAhBE,EACTN,EAAqBI,GAAOE,EAE5BP,EAAmBK,GAAOE,KAG9B,IAAMC,EAA0BN,OAAOC,KAAKF,GAAsBQ,OAAS,EAE3E,OAAO,SAACC,EAAcC,EAA4BC,GAChDC,EAAeF,GAAkB,SAASG,EAAKC,GAC7C,IAQMC,EARAC,EAAcF,EAAIG,IAAI,iBAAmB,GAC/C,OAAIpB,EAAKJ,wBAAwByB,KAAKF,GAChCH,GACFC,EAAIK,WACGR,EAAKE,KAEdC,EAAIM,aAAa,kBAGbb,GAEFQ,EAAkBjB,KAAQC,GAC1BE,OAAOC,KAAKF,GAAsBG,SAAQ,SAASC,EAAKC,GACtDU,EAAmBX,GAAOJ,EAAqBI,GAAKK,EAAKK,OAI3DC,EAAqBhB,OAGvBe,EAAIO,cDbV1B,EACAC,YAAAA,IAAAA,EAA4B,IAE5B,IAAMC,EAAIC,KAAiBR,EAAmBM,GACxC0B,EA3BR,SACE3B,EACAE,GAEA,OAAOI,OAAOC,KAAKP,GAChB4B,MAAK,SAACC,EAAGC,GAAC,OAAKA,EAAEjB,OAASgB,EAAEhB,UAC5BkB,KAAI,SAAAC,GAAM,MAAK,CACdC,QAAS,IAAIC,OACXC,EAAmBH,GACnB9B,EAAKL,WAAa,MAAQ,MAE5BuC,QAASpC,EAAagC,OAgBRK,CAAerC,EAAcE,GACzCoC,EAbR,SAA4BtC,GAC1B,OAAOM,OAAOC,KAAKP,GAAcuC,QAC/B,SAACC,EAAKR,GAAM,OAAKS,KAAKC,IAAIF,EAAKR,EAAOnB,UACtC,GAUsB8B,CAAmB3C,GACvC4C,EAAO,GA4DX,OAAO,IAAIC,YAAU,CAAEC,UAhCL,SAChBC,EACAC,EACAC,GAEA,IAAMC,EAAkC,EAAlBZ,EAChBa,EAAWP,EAAOG,EAAIK,SAASlD,EAAKN,UAG1C,GAAIuD,EAAStC,OAA2B,EAAlByB,EAAsB,EAG1C,OAFAM,EAAOO,OACPF,EAAG,KAAM,IAEV,IAAAI,EAvC0B,SAC3BF,EACAxB,EACAuB,GAWA,IAAII,EAAOH,EASX,OARAxB,EAAUnB,SAAQ,SAAA+C,GAChBD,EACEA,EACGE,MAAM,EAAGN,GACTd,QAAQmB,EAAStB,QAASsB,EAASnB,SACtCkB,EAAKE,MAAMN,MAGR,CAACI,EAAKE,MAAM,EAAGN,GAAgBI,EAAKE,MAAMN,IAkBlCO,CAAqBN,EAAUxB,EAAWuB,GAAlDN,EAAIS,KAEXJ,EAAG,KAFEI,OAiB2BK,MAbpB,SAAST,GAChBL,EASLK,EAAG,KAJUtB,EAAUY,QACrB,SAACC,EAAKe,GAAQ,OAAKf,EAAIJ,QAAQmB,EAAStB,QAASsB,EAASnB,WAC1DQ,IANAK,OC1CWU,CAAoBvC,IAAqBM,KAAKP,IAEhDA,EAAIK,cAGfR,MAIJ4C,OAAOC,QAAU9D,EACjB6D,OAAOC,QAAQ9D,cAAgBA"}